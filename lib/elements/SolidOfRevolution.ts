/**
 * Solid of Revolution - 3D solid generated by rotating a curve around an axis
 * 
 * Creates a 3D solid by revolving a 2D curve (function) around the Y axis.
 * Useful for visualizing concepts from calculus like volumes of revolution.
 */

import { 
  WebGL3DFigure, 
  type WebGL3DConfig, 
  type Material 
} from "./WebGL3DFigure.js";

export type RevolutionFunction = (y: number) => number;

export interface SolidOfRevolutionConfig extends Omit<WebGL3DConfig, 'width' | 'height'> {
  /** Function f(y) that defines the radius at each y value */
  radiusFunction: RevolutionFunction | string;
  /** Start of y range */
  yStart: number;
  /** End of y range */
  yEnd: number;
  /** Number of segments along the y axis */
  ySegments?: number;
  /** Number of segments around the revolution (radial) */
  radialSegments?: number;
  canvasWidth?: number;
  canvasHeight?: number;
  material?: Material;
  /** Whether to show the curve profile */
  showProfile?: boolean;
  profileMaterial?: Material;
}

/**
 * 3D Solid of Revolution
 * 
 * @example
 * ```typescript
 * // Sphere: r(y) = sqrt(1 - y^2), y from -1 to 1
 * const sphere = new SolidOfRevolution({
 *   radiusFunction: (y) => Math.sqrt(1 - y * y),
 *   yStart: -1,
 *   yEnd: 1,
 *   rotation: [20, 45, 0],
 * });
 * 
 * // Cone: r(y) = 1 - y, y from 0 to 1
 * const cone = new SolidOfRevolution({
 *   radiusFunction: (y) => 1 - y,
 *   yStart: 0,
 *   yEnd: 1,
 * });
 * 
 * // Paraboloid: r(y) = y^2, y from 0 to 1
 * const paraboloid = new SolidOfRevolution({
 *   radiusFunction: (y) => y * y,
 *   yStart: 0,
 *   yEnd: 1,
 * });
 * ```
 */
export class SolidOfRevolution extends WebGL3DFigure {
  private radiusFunction: RevolutionFunction;
  private yStart: number;
  private yEnd: number;
  private ySegments: number;
  private radialSegments: number;
  private material: Material;
  private showProfile: boolean;
  private profileMaterial?: Material;

  constructor(config: SolidOfRevolutionConfig) {
    const canvasWidth = config.canvasWidth ?? 400;
    const canvasHeight = config.canvasHeight ?? 400;
    
    super({
      ...config,
      width: canvasWidth,
      height: canvasHeight,
    });
    
    // Parse function if string
    if (typeof config.radiusFunction === 'string') {
      try {
        // Create function from string (e.g., "y => Math.sqrt(1 - y*y)")
        this.radiusFunction = eval(`(${config.radiusFunction})`);
      } catch (e) {
        console.error('Failed to parse radius function:', e);
        this.radiusFunction = () => 1;
      }
    } else {
      this.radiusFunction = config.radiusFunction;
    }
    
    this.yStart = config.yStart;
    this.yEnd = config.yEnd;
    this.ySegments = config.ySegments ?? 32;
    this.radialSegments = config.radialSegments ?? 32;
    
    this.material = config.material ?? {
      color: [0.5, 0.7, 0.9, 1.0],
      ambient: 0.3,
      diffuse: 0.6,
      specular: 0.5,
      shininess: 32,
    };
    
    this.showProfile = config.showProfile ?? false;
    this.profileMaterial = config.profileMaterial;
  }

  /**
   * Build solid of revolution geometry
   */
  protected buildGeometry(): void {
    const vertices: number[] = [];
    const normals: number[] = [];
    const indices: number[] = [];
    
    const yStep = (this.yEnd - this.yStart) / this.ySegments;
    const angleStep = (2 * Math.PI) / this.radialSegments;

    // Generate vertices
    for (let i = 0; i <= this.ySegments; i++) {
      const y = this.yStart + i * yStep;
      const radius = Math.max(0, this.radiusFunction(y));
      
      // Approximate derivative for normal calculation
      const dy = yStep * 0.01;
      const radiusNext = Math.max(0, this.radiusFunction(y + dy));
      const dr = radiusNext - radius;
      const tangentLen = Math.sqrt(dy * dy + dr * dr);
      const normalY = tangentLen > 0 ? dr / tangentLen : 0;
      const normalR = tangentLen > 0 ? dy / tangentLen : 1;

      for (let j = 0; j <= this.radialSegments; j++) {
        const angle = j * angleStep;
        const x = radius * Math.cos(angle);
        const z = radius * Math.sin(angle);

        vertices.push(x, y, z);
        
        // Normal (perpendicular to the surface)
        const nx = normalR * Math.cos(angle);
        const ny = normalY;
        const nz = normalR * Math.sin(angle);
        normals.push(nx, ny, nz);
      }
    }

    // Generate indices
    for (let i = 0; i < this.ySegments; i++) {
      for (let j = 0; j < this.radialSegments; j++) {
        const first = i * (this.radialSegments + 1) + j;
        const second = first + this.radialSegments + 1;

        indices.push(first, second, first + 1);
        indices.push(second, second + 1, first + 1);
      }
    }

    // Add caps if the radius is non-zero at the ends
    const radiusStart = this.radiusFunction(this.yStart);
    const radiusEnd = this.radiusFunction(this.yEnd);

    // Bottom cap
    if (radiusStart > 0.001) {
      const centerIdx = vertices.length / 3;
      vertices.push(0, this.yStart, 0);
      normals.push(0, -1, 0);

      for (let j = 0; j <= this.radialSegments; j++) {
        const angle = j * angleStep;
        const x = radiusStart * Math.cos(angle);
        const z = radiusStart * Math.sin(angle);
        vertices.push(x, this.yStart, z);
        normals.push(0, -1, 0);
      }

      for (let j = 0; j < this.radialSegments; j++) {
        indices.push(centerIdx, centerIdx + j + 2, centerIdx + j + 1);
      }
    }

    // Top cap
    if (radiusEnd > 0.001) {
      const centerIdx = vertices.length / 3;
      vertices.push(0, this.yEnd, 0);
      normals.push(0, 1, 0);

      for (let j = 0; j <= this.radialSegments; j++) {
        const angle = j * angleStep;
        const x = radiusEnd * Math.cos(angle);
        const z = radiusEnd * Math.sin(angle);
        vertices.push(x, this.yEnd, z);
        normals.push(0, 1, 0);
      }

      for (let j = 0; j < this.radialSegments; j++) {
        indices.push(centerIdx, centerIdx + j + 1, centerIdx + j + 2);
      }
    }

    this.vertices = new Float32Array(vertices);
    this.normals = new Float32Array(normals);
    this.indices = new Uint16Array(indices);
  }

  /**
   * Get points along the profile curve
   * Useful for labeling or showing the generating curve
   */
  getProfilePoints(numPoints: number = 20): Array<[number, number, number]> {
    const points: Array<[number, number, number]> = [];
    const step = (this.yEnd - this.yStart) / (numPoints - 1);
    
    for (let i = 0; i < numPoints; i++) {
      const y = this.yStart + i * step;
      const radius = Math.max(0, this.radiusFunction(y));
      points.push([radius, y, 0]); // Profile in XY plane
    }
    
    return points;
  }

  /**
   * Get a circle of points at a specific y value
   * Useful for showing cross-sections
   */
  getCrossSection(y: number, numPoints: number = 16): Array<[number, number, number]> {
    const points: Array<[number, number, number]> = [];
    const radius = Math.max(0, this.radiusFunction(y));
    const angleStep = (2 * Math.PI) / numPoints;
    
    for (let i = 0; i < numPoints; i++) {
      const angle = i * angleStep;
      const x = radius * Math.cos(angle);
      const z = radius * Math.sin(angle);
      points.push([x, y, z]);
    }
    
    return points;
  }

  /**
   * Get key points for labeling
   */
  getKeyPoints(): {
    top: [number, number, number];
    bottom: [number, number, number];
    maxRadius: { point: [number, number, number]; y: number };
  } {
    // Find maximum radius
    let maxRadius = 0;
    let maxRadiusY = this.yStart;
    const samples = 100;
    const step = (this.yEnd - this.yStart) / samples;
    
    for (let i = 0; i <= samples; i++) {
      const y = this.yStart + i * step;
      const radius = this.radiusFunction(y);
      if (radius > maxRadius) {
        maxRadius = radius;
        maxRadiusY = y;
      }
    }

    return {
      top: [0, this.yEnd, 0],
      bottom: [0, this.yStart, 0],
      maxRadius: {
        point: [maxRadius, maxRadiusY, 0],
        y: maxRadiusY,
      },
    };
  }

  /**
   * Render the solid
   */
  protected renderScene(): void {
    if (!this.gl || !this.canvas) return;

    const gl = this.gl;
    const program = (this as any).program;
    
    if (!program) return;

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    this.updateMatrices();

    // Set up buffers
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);

    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.normals, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    // Get locations
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    const aNormal = gl.getAttribLocation(program, 'aNormal');

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.enableVertexAttribArray(aNormal);
    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

    // Set uniforms
    const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
    const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
    const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
    const uNormalMatrix = gl.getUniformLocation(program, 'uNormalMatrix');
    const uLightPosition = gl.getUniformLocation(program, 'uLightPosition');
    const uLightColor = gl.getUniformLocation(program, 'uLightColor');
    const uLightIntensity = gl.getUniformLocation(program, 'uLightIntensity');
    const uCameraPosition = gl.getUniformLocation(program, 'uCameraPosition');
    const uMaterialColor = gl.getUniformLocation(program, 'uMaterialColor');
    const uAmbient = gl.getUniformLocation(program, 'uAmbient');
    const uDiffuse = gl.getUniformLocation(program, 'uDiffuse');
    const uSpecular = gl.getUniformLocation(program, 'uSpecular');
    const uShininess = gl.getUniformLocation(program, 'uShininess');

    gl.uniformMatrix4fv(uModelMatrix, false, this.modelMatrix);
    gl.uniformMatrix4fv(uViewMatrix, false, this.viewMatrix);
    gl.uniformMatrix4fv(uProjectionMatrix, false, this.projectionMatrix);
    gl.uniformMatrix4fv(uNormalMatrix, false, this.modelMatrix);

    const light = this.lights[0];
    gl.uniform3fv(uLightPosition, light.position);
    gl.uniform3fv(uLightColor, light.color);
    gl.uniform1f(uLightIntensity, light.intensity);
    gl.uniform3fv(uCameraPosition, this.camera.position);

    gl.uniform4fv(uMaterialColor, this.material.color);
    gl.uniform1f(uAmbient, this.material.ambient);
    gl.uniform1f(uDiffuse, this.material.diffuse);
    gl.uniform1f(uSpecular, this.material.specular);
    gl.uniform1f(uShininess, this.material.shininess);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.TRIANGLES, this.indices.length, gl.UNSIGNED_SHORT, 0);

    gl.deleteBuffer(positionBuffer);
    gl.deleteBuffer(normalBuffer);
    gl.deleteBuffer(indexBuffer);
  }
}

